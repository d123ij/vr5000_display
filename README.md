his project is to create a substitute display unit for Yaesu VR-5000 broad band receiver "famous" for failing LCDs. The design is made possible only because of prior work by kakiralime (this is youtube username). I would not have enough patience to pull this through myself. 
There are three parts to the project:
 - Hardware (PCB)
 - FPGA firmware project
 - RP2040 firmware project

1. PCB project. Pretty simple 2 layer board made with JLCPCB
2. FPGA project is to emulate functionality of NJU6575 IC used in the original LCD and pass data along to the RP2040 that does all the graphics. The vr5000 CPU does use read-modify-write approach when working with the display memory. Therefore, when the original display IC, NJU6575 is removed its buffer has to be simulated. In this project is was done using Lattce LCMXO2-1200HC FPGA ($7). The FPGA has internal flash memory and free tool set is provided from Lattice. It can be programmed using HW-USBN-2A clone from e-bay. The cheapest one at the time of this writing was around $20. In addition to simulating the memory buffer the FPGA also packages and sends data to the rp2040. Communication protocol is one-directional and uses 6 lines all from FPGA to rp2040. There are: CSN, CLK and DATA(3:0). Every transaction has three clock pulses and both edges of the clock are used for the data transfer. Two clocks are used to sent four bytes, the third clock is dummy to make sure rp2040 state machine never get stuck. There is only one command to send page and column number for data transfers. Data transactions are sent one byte per transfer. The FPGA system interface has to handle 5V, which is achieved by using 8 bit level shifter IC to deal with bi-directional data lines. WRN, RDN and A0 signals are input only and dealt with by using a current limiting resistor on the FPGA input. 
3. RP2040 is responsible for displaying data. All the graphic utilities are based on kakiralime's work. I used them pretty much unchanged. The firmware runs on top of FreeRTOS. Communication with the FPGA is done via PIO state machine. rp2040 is a slave, it monitors CSN and CLK signals and inputs data when clock transition is detected. Data are transferred from input FIFOs to memory via two chained DMA channels that operate continuously. I found that using one DMA in conjunction with interrupt is not fast enough and data are lost periodically with that approach. Chaining DMAs solved that. Once data arrived they placed in queue by ISR. One of the background tasks dequeues data and processes incoming commands and data. The data format for the LCD consumption follows the one in kakiralime work to minimize amount of work. I only updated in/out routines for a different CPU and restructured code somewhat. The utilized LCD model is the same, currently ~$10 delivered from AliExpress (I bough it from JR E-Shop). You can see the image from AliExpress in the image section. Programming of the rp2040 was done using debug interface and PI pico module as a debugger. I actually routed debugging connector out of receiver to modify software while operating radio. 
4. This project is not for faint-harted! You should be able to solder QFN packages and trap-door connectors with 0.6 mm pitch. To fit the new unit inside the receiver I reused the original plexiglass block by making a cavity large enough to fit the new PCB, which is fixed to the back of the LCD by sticky tape. Dremel tool is your friend here. The new display dimension is somewhat smaller than original LCD, you can see the space on the right side of the screen unoccupied by the LCD.
5. This design requires two power connections. The 5V power was taken from c5012 as 5v from the LCD connector is there even when the receiver is off. Backlight power was taken from TP5069. The board consumption was around 50-60mA. Backlight current was about 80mA. 
